# Return Oriented Programming

Abusing the ‘ret’ instruction and ret2libc attacks

## Setup

You should already have GDB and binutils from the last workshop. Ghidra might help but is not necessary.

I’m going to use “echo -e” to print out raw values to pipe into the program, but you can use python or some other tool.

Install ROPgadget, we will be using it: pip install ropgadget

Download the binaries we’re using here: [https://daviscybersec.ddns.net/workshops/bufov\_rop.zip](https://daviscybersec.ddns.net/workshops/bufov_rop.zip)

Vulnerable services on twinpeaks.rkevin.dev ports 30054 and 30055.

## Last time

* We took a look at how buffer overflows could allow us to execute arbitrary code. However, we relied on a function that was already in the binary.
* This time, we’re taking a look at the case where we don’t have a nicely packaged “target” function. How can we get arbitrary code execution then?
* Note: If you haven’t followed along the last workshop, please do so before this one! I’m gonna assume you know how to use buffer overflows to take control over the instruction pointer.
* We also explained that “ret” is equivalent to “pop %rip”. This is how we can point the instruction pointer to anywhere we like.
* But that also means we don’t have to “return” to the start of a function. We can go _anywhere_ we like!
* Before we take a look at return-oriented programming, let’s look at chaining function calls via a buffer overflow!
* Look at 1\_x86\_chain, compiled from chain.c. Your goal is to print out “myvalue is now: 1337”, then quit. How would you do that?
* The vuln part is exactly the same as last time! Let’s try starting there. We know how to call “callmefirst”, so let’s try that!

