# x64 Calling Conventions

* Hoo boy, that was a LOT of stuff! Depending on time constraints, I might [skip](https://docs.google.com/presentation/d/15A4pv1zScx2K8IxyLFspuToyGNOKuqC3y2uhhnHnI4I/edit#slide=id.g6b1e0e52b2_0_651) to the good stuff \(buffer overflows\), but if yall’re up to it let’s take a look at 64-bit calling conventions first!
* * It’s different, but not that different, from x86 conventions. Don’t be scared! You did most of the heavy lifting already!
* There are two major differences:
* * Stack values are now 8 bytes big, not 4 bytes
  * * That’s why 64-bit computers are 64-bit computers, they operate on 64 bits \(8 bytes\) at a time!
  * Function call arguments are passed **in registers** rather than on the stack!
  * * The return value, saved ebp \(although now called rbp\), and local variables remain on the stack. The only change is with the passed-in arguments.
* We can take a look at the disassembly of 2\_x64\_convention, which is compiled from the same source code as the x86 one. We’ll only be taking a look at how test3 is called. You can explore the rest on your own, and it’s not that different from x86.
* * Seriously, in your free time, grab a piece of paper and run through the assembly by yourself! This is extremely useful for understanding how exactly function calls work under the hood
* Here’s an excerpt from main:
* * mov $0x3, %edx
  * mov $0x2, %esi
  * mov $0x1, %edi
  * call test3
* The arguments are passed into the registers rdi, rsi, rdx, rcx, r8, r9, in that order.

